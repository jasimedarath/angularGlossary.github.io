<div class="container">
  <h1>React Components</h1>
  <p>Components are the building blocks of React applications. They let you split the UI into independent, reusable pieces and think about each piece in isolation.</p>

  <mat-tab-group>
    <mat-tab label="Functional Components">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Functional Components</h2>
        <div class="info-box">
          <p><strong>Functional components</strong> are JavaScript functions that return JSX. They are the modern and preferred way to write React components.</p>
          <ul>
            <li>Simple JavaScript functions that return JSX</li>
            <li>Can use React Hooks for state and lifecycle</li>
            <li>More concise and easier to test</li>
            <li>Better performance with less boilerplate</li>
            <li>Recommended for all new components</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{functionalComponents}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Class Components">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Class Components</h2>
        <div class="info-box warning">
          <p><strong>Class components</strong> are ES6 classes that extend React.Component. They are the legacy way of creating components.</p>
          <ul>
            <li>Use ES6 class syntax</li>
            <li>Have access to lifecycle methods</li>
            <li>Manage state with this.state and this.setState</li>
            <li>More verbose than functional components</li>
            <li>Still supported but not recommended for new code</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{classComponents}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Comparison">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Functional vs Class Components</h2>
        <div class="info-box">
          <p>Comparison between modern functional components and legacy class components.</p>
          <ul>
            <li><strong>Syntax:</strong> Functions vs Classes</li>
            <li><strong>State:</strong> useState hook vs this.state</li>
            <li><strong>Lifecycle:</strong> useEffect hook vs lifecycle methods</li>
            <li><strong>This binding:</strong> Not needed in functional components</li>
            <li><strong>Performance:</strong> Functional components are generally faster</li>
            <li><strong>Code size:</strong> Functional components are more concise</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{componentComparison}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Composition">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Component Composition</h2>
        <div class="info-box">
          <p><strong>Composition</strong> is the practice of building complex UIs by combining smaller, reusable components.</p>
          <ul>
            <li>Break down complex UIs into smaller pieces</li>
            <li>Create reusable component building blocks</li>
            <li>Pass components as props (children)</li>
            <li>Compose components together to build features</li>
            <li>Prefer composition over inheritance</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{componentComposition}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Import/Export">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Component Export and Import</h2>
        <div class="info-box">
          <p>Learn how to properly export and import React components across files.</p>
          <ul>
            <li><strong>Default export:</strong> One default export per file</li>
            <li><strong>Named export:</strong> Multiple named exports per file</li>
            <li>Import default: import App from './App'</li>
            <li>Import named: import &#123; Button &#125; from './Button'</li>
            <li>Mix both: import App, &#123; Button &#125; from './App'</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{componentExport}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Props">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Component Props</h2>
        <div class="info-box">
          <p><strong>Props</strong> (properties) are how you pass data from parent to child components.</p>
          <ul>
            <li>Props are read-only (immutable)</li>
            <li>Passed from parent to child components</li>
            <li>Can destructure props in function parameters</li>
            <li>Use default values with ES6 default parameters</li>
            <li>Spread operator to pass multiple props</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{componentProps}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Pure Components">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Pure Components & Memoization</h2>
        <div class="info-box success">
          <p><strong>Pure components</strong> only re-render when their props change, optimizing performance.</p>
          <ul>
            <li>React.memo() for functional components</li>
            <li>PureComponent for class components</li>
            <li>Shallow comparison of props</li>
            <li>Custom comparison function option</li>
            <li>Prevents unnecessary re-renders</li>
            <li>Use for expensive render operations</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{pureComponents}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Patterns">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Component Patterns</h2>
        <div class="info-box">
          <p>Common patterns for structuring React components effectively.</p>
          <ul>
            <li><strong>Container/Presentational:</strong> Separate logic from UI</li>
            <li><strong>Multiple returns:</strong> Early returns for conditions</li>
            <li><strong>Compound components:</strong> Components that work together</li>
            <li><strong>Props getters:</strong> Functions that return props</li>
            <li><strong>State reducers:</strong> Custom state logic</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{componentPatterns}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>
  <mat-tab label="Interview Q&A">
    <ng-template matTabContent>
      <div class="tab-content">
        <div class="interview-section">
          <h3>Expert/Senior/Architect Level Interview Questions</h3>
          
          <div class="question-block">
            <h4>Q1: How would you architect a component library for a large organization with multiple teams?</h4>
            <div class="answer">
              <p><strong>Answer:</strong></p>
              <ul>
                <li><strong>Design System:</strong> Create comprehensive design tokens (colors, spacing, typography) as foundation</li>
                <li><strong>Composition Pattern:</strong> Build atomic components (atoms, molecules, organisms) that compose into larger patterns</li>
                <li><strong>TypeScript:</strong> Use strict TypeScript with comprehensive prop types and generics</li>
                <li><strong>Documentation:</strong> Use Storybook with MDX for interactive documentation and examples</li>
                <li><strong>Testing:</strong> Implement comprehensive unit, integration, and visual regression tests</li>
                <li><strong>Versioning:</strong> Semantic versioning with changelogs and migration guides</li>
                <li><strong>Distribution:</strong> Publish as npm packages with tree-shaking support and bundle size monitoring</li>
                <li><strong>Accessibility:</strong> WCAG 2.1 AA compliance with ARIA patterns and keyboard navigation</li>
              </ul>
            </div>
          </div>

          <div class="question-block">
            <h4>Q2: Explain component re-rendering optimization strategies at an architectural level.</h4>
            <div class="answer">
              <p><strong>Answer:</strong></p>
              <ul>
                <li><strong>React.memo:</strong> Wrap components to prevent re-renders when props haven't changed (shallow comparison)</li>
                <li><strong>useMemo/useCallback:</strong> Memoize values and functions to maintain referential equality</li>
                <li><strong>Component Splitting:</strong> Break large components into smaller ones to isolate re-renders</li>
                <li><strong>Children Prop:</strong> Pass static content as children to avoid re-creating it</li>
                <li><strong>State Placement:</strong> Move state down to leaves or up to shared ancestors strategically</li>
                <li><strong>Context Splitting:</strong> Split contexts to prevent all consumers from re-rendering</li>
                <li><strong>Virtualization:</strong> Use react-window or react-virtualized for large lists</li>
                <li><strong>Profiling:</strong> Use React DevTools Profiler to measure and identify actual bottlenecks</li>
              </ul>
            </div>
          </div>

          <div class="question-block">
            <h4>Q3: What are the advanced patterns for component composition and prop management?</h4>
            <div class="answer">
              <p><strong>Answer:</strong></p>
              <ul>
                <li><strong>Compound Components:</strong> Parent-child components that share state (e.g., Tabs/Tab pattern)</li>
                <li><strong>Render Props:</strong> Pass functions as props to share code between components</li>
                <li><strong>Higher-Order Components:</strong> Functions that take component and return enhanced component</li>
                <li><strong>Custom Hooks:</strong> Modern approach to share stateful logic without wrapper components</li>
                <li><strong>Slot Pattern:</strong> Use named slots for flexible component composition</li>
                <li><strong>Prop Getters:</strong> Return props objects from hooks for consistent prop application</li>
                <li><strong>Polymorphic Components:</strong> Use 'as' prop to change rendered element type</li>
              </ul>
            </div>
          </div>

          <div class="question-block">
            <h4>Q4: How do you handle component error boundaries and error handling at scale?</h4>
            <div class="answer">
              <p><strong>Answer:</strong></p>
              <ul>
                <li><strong>Error Boundaries:</strong> Class components with componentDidCatch and getDerivedStateFromError</li>
                <li><strong>Granular Boundaries:</strong> Place error boundaries at strategic levels (page, section, widget)</li>
                <li><strong>Fallback UI:</strong> Provide contextual fallback UIs with recovery options</li>
                <li><strong>Error Reporting:</strong> Integrate with services like Sentry, LogRocket, Bugsnag</li>
                <li><strong>Retry Logic:</strong> Implement retry mechanisms for transient failures</li>
                <li><strong>Async Errors:</strong> Error boundaries don't catch async errors - handle those separately</li>
                <li><strong>Development vs Production:</strong> Show detailed errors in dev, user-friendly messages in prod</li>
                <li><strong>React 18 Suspense:</strong> Combine with Suspense for async error handling</li>
              </ul>
            </div>
          </div>

          <div class="question-block">
            <h4>Q5: What strategies would you use for component testing in a large codebase?</h4>
            <div class="answer">
              <p><strong>Answer:</strong></p>
              <ul>
                <li><strong>Testing Library:</strong> Use React Testing Library for user-centric component tests</li>
                <li><strong>Unit Tests:</strong> Test individual components in isolation with mocked dependencies</li>
                <li><strong>Integration Tests:</strong> Test component interactions and data flow between components</li>
                <li><strong>Visual Regression:</strong> Use tools like Chromatic or Percy for visual testing</li>
                <li><strong>Accessibility Testing:</strong> Use jest-axe or axe-core for automated a11y tests</li>
                <li><strong>Mock Service Worker:</strong> Use MSW to mock API calls at network level</li>
                <li><strong>Test Coverage:</strong> Aim for high coverage but focus on critical user flows</li>
                <li><strong>E2E Tests:</strong> Complement with Cypress or Playwright for critical paths</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </ng-template>
  </mat-tab>
  </mat-tab-group>
</div>
