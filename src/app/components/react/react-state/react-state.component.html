<div class="container">
  <h1>React State</h1>
  <p>State is a built-in React object used to store data that determines how a component renders and behaves. When state changes, the component re-renders to reflect the new state.</p>

  <mat-tab-group>
    <mat-tab label="State Basics">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Understanding State</h2>
        <div class="info-box">
          <p><strong>State</strong> is mutable data that belongs to a component and can change over time.</p>
          <ul>
            <li>useState hook for functional components</li>
            <li>Returns a state variable and setter function</li>
            <li>Initial value passed as argument to useState</li>
            <li>Setting state triggers a re-render</li>
            <li>State updates are asynchronous</li>
            <li>Each component has its own state</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{stateBasics}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Objects">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>State with Objects</h2>
        <div class="info-box">
          <p>When state is an object, always create a new object with spread operator to update it.</p>
          <ul>
            <li>Always spread existing state when updating</li>
            <li>React uses shallow comparison for state</li>
            <li>Don't mutate state directly</li>
            <li>Use functional updates for safer updates</li>
            <li>Handle nested objects carefully</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{stateObjects}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Arrays">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>State with Arrays</h2>
        <div class="info-box">
          <p>Managing arrays in state requires creating new arrays instead of mutating existing ones.</p>
          <ul>
            <li>Use spread operator or array methods that return new arrays</li>
            <li>Add items: [...array, newItem]</li>
            <li>Remove items: array.filter()</li>
            <li>Update items: array.map()</li>
            <li>Avoid push(), pop(), splice() - they mutate</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{stateArrays}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Functional Updates">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Functional State Updates</h2>
        <div class="info-box success">
          <p><strong>Functional updates</strong> use the previous state value to calculate the next state, ensuring accuracy.</p>
          <ul>
            <li>Pass a function to state setter instead of a value</li>
            <li>Function receives previous state as argument</li>
            <li>Necessary for multiple state updates</li>
            <li>Prevents stale closure issues</li>
            <li>More reliable for computed state changes</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{functionalUpdates}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Lazy Initialization">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>Lazy Initial State</h2>
        <div class="info-box">
          <p><strong>Lazy initialization</strong> runs the initialization function only once, not on every render.</p>
          <ul>
            <li>Pass a function to useState instead of a value</li>
            <li>Function runs only on initial render</li>
            <li>Useful for expensive computations</li>
            <li>Common with localStorage reads</li>
            <li>Improves performance for heavy initializations</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{lazyInitialization}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Class Components">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>State in Class Components</h2>
        <div class="info-box warning">
          <p><strong>Class components</strong> use this.state and this.setState() (legacy approach).</p>
          <ul>
            <li>Initialize state in constructor</li>
            <li>this.setState() to update state</li>
            <li>setState merges object updates automatically</li>
            <li>Can pass callback to setState</li>
            <li>Can use functional form of setState</li>
            <li>Prefer functional components with hooks</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{classComponentState}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

    <mat-tab label="Best Practices">
    <ng-template matTabContent>
      <div class="tab-content">
        <h2>State Management Best Practices</h2>
        <div class="info-box success">
          <h3>✓ Best Practices</h3>
          <ul>
            <li>Never mutate state directly</li>
            <li>Use functional updates when new state depends on previous state</li>
            <li>Split unrelated state into multiple useState calls</li>
            <li>Keep state minimal - derive values when possible</li>
            <li>Use lazy initialization for expensive initial values</li>
            <li>Prefer simple state structures over complex nested objects</li>
            <li>Consider useReducer for complex state logic</li>
            <li>Lift state up when multiple components need it</li>
          </ul>
        </div>
        <pre><code class="language-jsx">{{stateBestPractices}}</code></pre>
      </div>
    </ng-template>
  </mat-tab>
  <mat-tab label="Interview Q&A">
    <ng-template matTabContent>
      <div class="tab-content">
        <div class="interview-section">
          <h3>Expert/Senior/Architect Level Interview Questions</h3>
          
          <div class="question-block">
            <h4>Q1: Explain the difference between state updates in React 17 vs React 18 and their implications.</h4>
            <div class="answer">
              <p><strong>Answer:</strong></p>
              <ul>
                <li><strong>React 17 Batching:</strong> Only batches state updates in React event handlers</li>
                <li><strong>React 18 Automatic Batching:</strong> Batches updates everywhere (promises, setTimeout, native events)</li>
                <li><strong>Performance:</strong> React 18 reduces re-renders by batching more updates automatically</li>
                <li><strong>Opt-out:</strong> Use flushSync() to force immediate synchronous updates if needed</li>
                <li><strong>Concurrent Features:</strong> React 18 enables transitions and suspense for better UX</li>
                <li><strong>Migration:</strong> Most apps benefit automatically; check for code assuming synchronous setState</li>
              </ul>
            </div>
          </div>

          <div class="question-block">
            <h4>Q2: How would you architect state management for a complex multi-module enterprise application?</h4>
            <div class="answer">
              <p><strong>Answer:</strong></p>
              <ul>
                <li><strong>Layered Architecture:</strong> Local state → Context → Global state manager based on scope</li>
                <li><strong>Module Isolation:</strong> Each module manages its own state, shared state in higher layers</li>
                <li><strong>State Manager Choice:</strong> Redux Toolkit for complex apps, Zustand for simpler needs</li>
                <li><strong>Normalized State:</strong> Normalize entities like database (users, posts by ID)</li>
                <li><strong>Derived State:</strong> Use selectors/computed values instead of duplicating state</li>
                <li><strong>Async State:</strong> Handle loading, error, data states with consistent patterns</li>
                <li><strong>Persistence:</strong> Integrate redux-persist or similar for state hydration</li>
                <li><strong>DevTools:</strong> Implement time-travel debugging and state inspection tools</li>
              </ul>
            </div>
          </div>

          <div class="question-block">
            <h4>Q3: What are the common state management anti-patterns and how do you avoid them?</h4>
            <div class="answer">
              <p><strong>Answer:</strong></p>
              <ul>
                <li><strong>Anti-pattern: Prop Drilling:</strong> Passing props through many layers. Solution: Context or state manager</li>
                <li><strong>Anti-pattern: Duplicated State:</strong> Storing same data in multiple places. Solution: Single source of truth</li>
                <li><strong>Anti-pattern: Storing Derived Data:</strong> Caching computed values. Solution: Calculate on render or use useMemo</li>
                <li><strong>Anti-pattern: Mutating State:</strong> Direct mutation. Solution: Always create new objects/arrays</li>
                <li><strong>Anti-pattern: Over-globalization:</strong> All state in global store. Solution: Keep state close to where it's used</li>
                <li><strong>Anti-pattern: Async setState Logic:</strong> Complex logic in components. Solution: Custom hooks or middleware</li>
              </ul>
            </div>
          </div>

          <div class="question-block">
            <h4>Q4: How do you handle optimistic UI updates and rollback on failure?</h4>
            <div class="answer">
              <p><strong>Answer:</strong></p>
              <ul>
                <li><strong>Immediate Update:</strong> Update UI state immediately when user takes action</li>
                <li><strong>Store Snapshot:</strong> Keep snapshot of previous state for rollback</li>
                <li><strong>API Call:</strong> Make async API call in background</li>
                <li><strong>Success Path:</strong> On success, confirm the update or merge server response</li>
                <li><strong>Failure Path:</strong> On error, revert to snapshot and show error message</li>
                <li><strong>Loading States:</strong> Show subtle loading indicators during optimistic update</li>
                <li><strong>Conflict Resolution:</strong> Handle cases where server state differs from optimistic state</li>
                <li><strong>Tools:</strong> Libraries like React Query or SWR handle this pattern well</li>
              </ul>
            </div>
          </div>

          <div class="question-block">
            <h4>Q5: Explain strategies for state persistence and hydration in React applications.</h4>
            <div class="answer">
              <p><strong>Answer:</strong></p>
              <ul>
                <li><strong>localStorage:</strong> Store state in localStorage for browser-level persistence</li>
                <li><strong>sessionStorage:</strong> Use for tab-specific temporary state</li>
                <li><strong>IndexedDB:</strong> For large amounts of data that exceed localStorage limits</li>
                <li><strong>URL State:</strong> Persist UI state in URL query params for shareability</li>
                <li><strong>Redux Persist:</strong> Automatically sync Redux store with storage</li>
                <li><strong>Server State:</strong> Store user preferences on server and sync on login</li>
                <li><strong>Hydration Mismatch:</strong> Ensure client initial render matches server render (SSR)</li>
                <li><strong>Security:</strong> Never store sensitive data; encrypt if necessary</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </ng-template>
  </mat-tab>
  </mat-tab-group>
</div>
