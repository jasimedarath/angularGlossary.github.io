<h2 class="header">Built-in Control Flow</h2>
<label>Angular's new built-in control flow syntax provides a more intuitive and performant way to handle conditional rendering and loops in templates.</label>

<mat-tab-group>
  <mat-tab label="@if">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Conditional Rendering with &#64;if</h3>
        <p>
          The new <code>&#64;if</code> syntax replaces <code>*ngIf</code> with a cleaner, more intuitive syntax
          that's familiar to developers from other frameworks and languages.
        </p>
        
        <h4>Key Advantages</h4>
        <ul>
          <li><strong>Better readability:</strong> More concise and easier to understand</li>
          <li><strong>Type inference:</strong> Full TypeScript type narrowing support</li>
          <li><strong>Performance:</strong> More optimized compiled output</li>
          <li><strong>No imports needed:</strong> Built into Angular's template syntax</li>
        </ul>

        <h4>Syntax Comparison</h4>
        <pre><code class="language-typescript">{{ ifSyntax }}</code></pre>

        <div class="info-box">
          <h4>üí° Type Narrowing</h4>
          <p>
            The control flow block provides automatic type narrowing. If you check for nullability,
            TypeScript knows the value is defined within the if block.
          </p>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="@for">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Looping with &#64;for</h3>
        <p>
          The <code>&#64;for</code> block replaces <code>*ngFor</code> and requires an explicit track expression,
          making it impossible to accidentally create performance issues.
        </p>
        
        <h4>Required Track Expression</h4>
        <p>
          Unlike *ngFor where trackBy was optional, &#64;for <strong>requires</strong> a track expression.
          This forces you to think about item identity and prevents common performance pitfalls.
        </p>

        <h4>Available Context Variables</h4>
        <ul>
          <li><code>$index</code> - Current index (0-based)</li>
          <li><code>$first</code> - Boolean indicating if it's the first item</li>
          <li><code>$last</code> - Boolean indicating if it's the last item</li>
          <li><code>$even</code> - Boolean indicating if index is even</li>
          <li><code>$odd</code> - Boolean indicating if index is odd</li>
          <li><code>$count</code> - Total number of items</li>
        </ul>

        <pre><code class="language-typescript">{{ forSyntax }}</code></pre>

        <div class="warning-box">
          <h4>‚ö†Ô∏è Track Expression Best Practices</h4>
          <ul>
            <li>Use unique identifiers (id, uuid) when available</li>
            <li>Avoid using $index for dynamic lists (items can be added/removed)</li>
            <li>For primitive arrays, tracking by value is acceptable</li>
            <li>Complex objects should track by a unique property</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="@switch">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Multi-way Branching with &#64;switch</h3>
        <p>
          The <code>&#64;switch</code> block provides a cleaner alternative to <code>ngSwitch</code>,
          with better type checking and more intuitive syntax.
        </p>

        <h4>When to Use &#64;switch</h4>
        <ul>
          <li>When you have more than 2-3 conditions based on the same value</li>
          <li>When working with enums or union types</li>
          <li>When you need a default fallback case</li>
          <li>For rendering different components based on a state</li>
        </ul>

        <h4>Advantages Over &#64;if Chains</h4>
        <ul>
          <li>More readable for multiple conditions</li>
          <li>Better performance (single expression evaluation)</li>
          <li>Exhaustiveness checking with TypeScript</li>
          <li>Clearer intent in the code</li>
        </ul>

        <pre><code class="language-typescript">{{ switchSyntax }}</code></pre>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Tracking & Performance">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Understanding Track Expressions</h3>
        <p>
          The track expression tells Angular how to identify items in a list. This is crucial for performance
          because it allows Angular to reuse DOM elements instead of destroying and recreating them.
        </p>

        <h4>Why Tracking Matters</h4>
        <ul>
          <li><strong>DOM reuse:</strong> Angular reuses elements for unchanged items</li>
          <li><strong>State preservation:</strong> Component state is maintained across updates</li>
          <li><strong>Better performance:</strong> Fewer DOM operations mean faster updates</li>
          <li><strong>Animation continuity:</strong> Animations aren't interrupted unnecessarily</li>
        </ul>

        <h4>Tracking Strategies</h4>
        <pre><code class="language-typescript">{{ trackingFunction }}</code></pre>

        <div class="performance-tips">
          <h4>üöÄ Performance Tips</h4>
          <ul>
            <li>Always use object IDs when available (track item.id)</li>
            <li>Avoid tracking by $index unless the list is truly static</li>
            <li>For lists that reorder, never use $index</li>
            <li>Consider composite keys for nested data structures</li>
            <li>Profile with Chrome DevTools to identify performance issues</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Complex Example">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Real-World Complex Example</h3>
        <p>
          This example demonstrates how to combine multiple control flow blocks to create
          sophisticated UI logic with excellent performance and type safety.
        </p>

        <pre><code class="language-typescript">{{ complexExample }}</code></pre>

        <h3>Performance Comparison</h3>
        <pre><code class="language-typescript">{{ performanceComparison }}</code></pre>

        <div class="migration-tip">
          <h4>üì¶ Migration Guide</h4>
          <p>Angular provides an automated migration schematic:</p>
          <pre><code>ng generate &#64;angular/core:control-flow</code></pre>
          <p>This will automatically convert your templates to use the new control flow syntax.</p>
          
          <h4>What Gets Migrated</h4>
          <ul>
            <li>*ngIf ‚Üí &#64;if</li>
            <li>*ngFor ‚Üí &#64;for (with automatic trackBy conversion)</li>
            <li>ngSwitch ‚Üí &#64;switch</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>
</mat-tab-group>
