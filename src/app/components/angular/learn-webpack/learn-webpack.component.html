<h2 class="header">Webpack</h2>
<label>Webpack is the powerful module bundler that powers Angular CLI, transforming and optimizing your application code for production deployment.</label>

<mat-tab-group>
  <mat-tab label="Introduction">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Webpack in Angular</h3>
        <p>
          Webpack is a static module bundler for modern JavaScript applications. Angular CLI uses Webpack under the hood
          to bundle your application code, assets, and dependencies into optimized bundles for deployment.
        </p>
        
        <h4>What Webpack Does</h4>
        <ul>
          <li><strong>Module Bundling:</strong> Combines multiple files into optimized bundles</li>
          <li><strong>Code Transformation:</strong> Converts TypeScript to JavaScript, SCSS to CSS</li>
          <li><strong>Asset Management:</strong> Handles images, fonts, and other assets</li>
          <li><strong>Code Optimization:</strong> Minifies, tree-shakes, and compresses code</li>
          <li><strong>Development Server:</strong> Provides hot module replacement for dev</li>
        </ul>

        <h4>Webpack Core Concepts</h4>
        <ul>
          <li>ğŸ¯ <strong>Entry:</strong> Starting point of your application (main.ts)</li>
          <li>ğŸ“¦ <strong>Output:</strong> Bundled files in dist/ folder</li>
          <li>ğŸ”„ <strong>Loaders:</strong> Transform files (TypeScript, SASS, etc.)</li>
          <li>ğŸ”Œ <strong>Plugins:</strong> Optimize bundles, inject scripts, minify</li>
          <li>ğŸ“Š <strong>Mode:</strong> Development or production configuration</li>
        </ul>

        <h4>Why Angular Uses Webpack</h4>
        <ul>
          <li>Powerful ecosystem with extensive plugin support</li>
          <li>Excellent code splitting and lazy loading capabilities</li>
          <li>Tree shaking for removing unused code</li>
          <li>Hot Module Replacement for better development experience</li>
          <li>Mature and battle-tested in production environments</li>
        </ul>

        <div class="code-note"><p>Webpack configuration and examples are handled through angular.json and Angular CLI build system</p></div>

        <div class="info-box">
          <h4>ğŸ’¡ Angular CLI Abstraction</h4>
          <p>
            Angular CLI abstracts most Webpack configuration, making it easier to get started.
            Most configuration is done through angular.json, but you can customize Webpack config for advanced use cases.
          </p>
        </div>

        <div class="tip-box">
          <h4>ğŸ¯ Understanding Bundles</h4>
          <ul>
            <li><strong>main.js:</strong> Your application code and components</li>
            <li><strong>polyfills.js:</strong> Browser compatibility polyfills</li>
            <li><strong>runtime.js:</strong> Webpack module loading logic</li>
            <li><strong>styles.css:</strong> Compiled global stylesheets</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Bundle Optimization">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Optimizing Bundle Size</h3>
        <p>
          Bundle optimization is crucial for application performance. Smaller bundles load faster, improving
          user experience and SEO rankings. Angular CLI provides several optimization strategies.
        </p>
        
        <h4>Optimization Strategies</h4>
        <ul>
          <li><strong>Tree Shaking:</strong> Remove unused code automatically</li>
          <li><strong>Minification:</strong> Compress JavaScript and CSS</li>
          <li><strong>Code Splitting:</strong> Split code into smaller chunks</li>
          <li><strong>Lazy Loading:</strong> Load features on demand</li>
          <li><strong>Asset Optimization:</strong> Compress images and fonts</li>
        </ul>

        <h4>Bundle Size Budgets</h4>
        <ul>
          <li>Set maximum sizes for different bundle types</li>
          <li>Build fails or warns when budgets are exceeded</li>
          <li>Prevents accidental bundle size increases</li>
          <li>Configurable per bundle type (initial, lazy, etc.)</li>
        </ul>

        <h4>Analyzing Bundle Size</h4>
        <ul>
          <li>ğŸ“Š Use webpack-bundle-analyzer for visual analysis</li>
          <li>ğŸ” Identify large dependencies taking up space</li>
          <li>ğŸ“ˆ Track bundle size changes over time</li>
          <li>ğŸ¯ Find optimization opportunities</li>
        </ul>

        <div class="code-note"><p>Bundle optimization settings can be configured in angular.json under build configuration options including budgets, optimization flags, and source maps</p></div>

        <div class="info-box">
          <h4>ğŸ’¡ Bundle Size Best Practices</h4>
          <p>
            Aim to keep your initial bundle under 500KB (gzipped). Larger bundles significantly impact
            load time on slower networks. Use lazy loading for features not needed on initial load.
          </p>
        </div>

        <div class="warning-box">
          <h4>âš ï¸ Common Bundle Size Issues</h4>
          <ul>
            <li>Importing entire libraries instead of specific modules</li>
            <li>Not lazy loading rarely-used features</li>
            <li>Including development dependencies in production</li>
            <li>Large image assets not optimized</li>
          </ul>
        </div>

        <div class="tip-box">
          <h4>ğŸ¯ Quick Wins</h4>
          <ul>
            <li>Replace moment.js with date-fns (10x smaller)</li>
            <li>Use lodash-es with tree-shaking, not lodash</li>
            <li>Import specific RxJS operators, not entire library</li>
            <li>Enable production mode optimizations</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Code Splitting">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Code Splitting Strategies</h3>
        <p>
          Code splitting divides your application into smaller chunks that can be loaded on demand.
          This reduces initial bundle size and improves load times by only loading code when needed.
        </p>
        
        <h4>Types of Code Splitting</h4>
        <ul>
          <li><strong>Route-based:</strong> Split by lazy-loaded routes (most common)</li>
          <li><strong>Component-based:</strong> Lazy load heavy components</li>
          <li><strong>Vendor splitting:</strong> Separate third-party libraries</li>
          <li><strong>Dynamic imports:</strong> Load code programmatically</li>
        </ul>

        <h4>Preloading Strategies</h4>
        <ul>
          <li><strong>NoPreloading:</strong> Only load when navigated (default for lazy)</li>
          <li><strong>PreloadAllModules:</strong> Load all lazy modules after initial load</li>
          <li><strong>Custom Strategy:</strong> Selective preloading based on conditions</li>
        </ul>

        <h4>Benefits of Code Splitting</h4>
        <ul>
          <li>âš¡ Faster initial page load</li>
          <li>ğŸ“¦ Smaller initial bundle size</li>
          <li>ğŸ¯ Better caching (unchanged chunks stay cached)</li>
          <li>ğŸš€ Improved perceived performance</li>
          <li>ğŸ“± Better for mobile and slow networks</li>
        </ul>

        <div class="code-note"><p>Code splitting is implemented through lazy-loaded routes in app.routes.ts and dynamic imports for components</p></div>

        <div class="info-box">
          <h4>ğŸ’¡ When to Split Code</h4>
          <p>
            Split code for features used by a subset of users (admin panels, settings) or
            rarely accessed features. Don't over-split code that's needed immediately.
          </p>
        </div>

        <div class="tip-box">
          <h4>ğŸ¯ Splitting Best Practices</h4>
          <ul>
            <li>Lazy load entire feature modules, not individual components</li>
            <li>Use preloading for frequently accessed routes</li>
            <li>Monitor chunk sizes - aim for 50-200KB per chunk</li>
            <li>Consider network round-trip costs vs bundle size</li>
          </ul>
        </div>

        <div class="warning-box">
          <h4>âš ï¸ Over-splitting Warning</h4>
          <p>
            Too many small chunks can hurt performance due to HTTP overhead. Each chunk requires
            a separate network request. Balance chunk count with chunk size.
          </p>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Tree Shaking">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Tree Shaking</h3>
        <p>
          Tree shaking eliminates unused code from your bundle. It's a form of dead code elimination that
          relies on ES6 module syntax to determine which exports are used and which can be safely removed.
        </p>
        
        <h4>How Tree Shaking Works</h4>
        <ul>
          <li><strong>Static Analysis:</strong> Analyzes import/export statements</li>
          <li><strong>Mark Phase:</strong> Marks used exports in dependency graph</li>
          <li><strong>Sweep Phase:</strong> Removes unmarked (unused) code</li>
          <li><strong>Optimization:</strong> Enabled automatically in production builds</li>
        </ul>

        <h4>Requirements for Tree Shaking</h4>
        <ul>
          <li>âœ… Use ES6 import/export syntax</li>
          <li>âœ… Production mode build</li>
          <li>âœ… Side-effect free code</li>
          <li>âœ… Proper package.json configuration</li>
        </ul>

        <h4>Tree Shaking Benefits</h4>
        <ul>
          <li>ğŸŒ³ Removes unused library code automatically</li>
          <li>ğŸ“‰ Significantly reduces bundle size</li>
          <li>âš¡ Faster load times and better performance</li>
          <li>ğŸ”§ Works automatically in production builds</li>
        </ul>

        <div class="code-note"><p>Tree shaking is automatically enabled in production builds and works best with ES6 modules and providedIn services</p></div>

        <div class="info-box">
          <h4>ğŸ’¡ Side Effects</h4>
          <p>
            Code with side effects (like setting global variables or modifying prototypes) can't be safely removed.
            Mark side-effect free packages in package.json with <code>"sideEffects": false</code>.
          </p>
        </div>

        <div class="tip-box">
          <h4>ğŸ¯ Maximizing Tree Shaking</h4>
          <ul>
            <li>Import specific items: <code>import &#123; map &#125; from 'rxjs/operators'</code></li>
            <li>Avoid namespace imports: <code>import * as rxjs from 'rxjs'</code></li>
            <li>Use providedIn: 'root' for services (tree-shakeable)</li>
            <li>Mark libraries as side-effect free when possible</li>
          </ul>
        </div>

        <div class="warning-box">
          <h4>âš ï¸ Tree Shaking Limitations</h4>
          <ul>
            <li>Doesn't work with CommonJS modules (require/exports)</li>
            <li>Dynamic imports with variables prevent tree shaking</li>
            <li>Side effects can prevent code removal</li>
            <li>Some libraries aren't tree-shakeable</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Build Configuration">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Custom Build Configuration</h3>
        <p>
          While Angular CLI handles most Webpack configuration, you can customize builds for advanced scenarios
          using custom webpack builders or angular.json configuration options.
        </p>
        
        <h4>Configuration Options</h4>
        <ul>
          <li><strong>angular.json:</strong> Standard CLI configuration</li>
          <li><strong>Custom Webpack Config:</strong> Advanced Webpack customization</li>
          <li><strong>Build Environments:</strong> Different configs for dev/prod/staging</li>
          <li><strong>Builders:</strong> Custom build processes</li>
        </ul>

        <h4>Common Customizations</h4>
        <ul>
          <li>ğŸ”§ Adding custom Webpack plugins</li>
          <li>ğŸ“ Configuring custom loaders for file types</li>
          <li>ğŸ”— Setting up resolve aliases for imports</li>
          <li>ğŸŒ Configuring dev server proxy</li>
          <li>ğŸ“¦ Custom bundle splitting strategies</li>
        </ul>

        <h4>When to Customize Webpack</h4>
        <ul>
          <li>Need to support custom file types</li>
          <li>Integration with specialized build tools</li>
          <li>Advanced optimization requirements</li>
          <li>Custom asset processing pipelines</li>
          <li>Legacy code migration needs</li>
        </ul>

        <div class="code-note"><p>Build configuration examples include custom webpack builders, angular.json settings, and environment-specific configurations</p></div>

        <div class="info-box">
          <h4>ğŸ’¡ Custom Webpack Builder</h4>
          <p>
            Use <code>&#64;angular-builders/custom-webpack</code> to extend Angular CLI's Webpack configuration
            without ejecting. This allows you to add custom loaders, plugins, and other Webpack features.
          </p>
        </div>

        <div class="warning-box">
          <h4>âš ï¸ Configuration Cautions</h4>
          <ul>
            <li>Custom configs can break on Angular CLI updates</li>
            <li>Thoroughly test custom configurations</li>
            <li>Document why customization is needed</li>
            <li>Consider if Angular CLI options are sufficient first</li>
          </ul>
        </div>

        <div class="tip-box">
          <h4>ğŸ¯ Configuration Tips</h4>
          <ul>
            <li>Start with angular.json before custom Webpack</li>
            <li>Use merge strategies to combine configurations</li>
            <li>Test custom configs in CI/CD pipeline</li>
            <li>Keep custom config minimal and focused</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Production Optimizations">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Production Build Optimizations</h3>
        <p>
          Production builds apply aggressive optimizations to reduce bundle size, improve load times,
          and ensure the best possible performance for end users.
        </p>
        
        <h4>Automatic Optimizations</h4>
        <ul>
          <li><strong>AOT Compilation:</strong> Ahead-of-time compiles templates</li>
          <li><strong>Build Optimizer:</strong> Angular-specific optimizations</li>
          <li><strong>Minification:</strong> Removes whitespace and shortens names</li>
          <li><strong>Tree Shaking:</strong> Removes unused code</li>
          <li><strong>Hashing:</strong> Adds hashes to filenames for caching</li>
        </ul>

        <h4>Additional Optimizations</h4>
        <ul>
          <li>ğŸ—œï¸ <strong>Compression:</strong> Gzip/Brotli compression</li>
          <li>ğŸ’¾ <strong>Service Worker:</strong> Offline caching with PWA</li>
          <li>ğŸ“± <strong>Differential Loading:</strong> ES5 and ES2015+ bundles</li>
          <li>ğŸ¨ <strong>Critical CSS:</strong> Inline critical styles</li>
          <li>ğŸ–¼ï¸ <strong>Image Optimization:</strong> Compress and lazy-load images</li>
        </ul>

        <h4>Caching Strategy</h4>
        <ul>
          <li>Content hashing for long-term caching</li>
          <li>Service worker for app shell caching</li>
          <li>HTTP cache headers configuration</li>
          <li>CDN integration for static assets</li>
        </ul>

        <div class="code-note">
          <h4>ğŸ“ Configuration Note</h4>
          <p>Production builds automatically enable AOT compilation, build optimizer, minification, and output hashing.</p>
          <p>Configure in angular.json under projects > yourApp > architect > build > configurations > production</p>
        </div>

        <div class="best-practices">
          <h4>âœ… Production Checklist</h4>
          <ul>
            <li><strong>Enable AOT:</strong> Compile templates ahead of time</li>
            <li><strong>Use Build Optimizer:</strong> Angular-specific optimizations</li>
            <li><strong>Enable Compression:</strong> Configure server for gzip/brotli</li>
            <li><strong>Set Cache Headers:</strong> Long-term caching for hashed files</li>
            <li><strong>Add Service Worker:</strong> Offline support and caching</li>
            <li><strong>Monitor Bundle Size:</strong> Set up CI checks</li>
          </ul>
        </div>

        <div class="info-box">
          <h4>ğŸ’¡ Differential Loading</h4>
          <p>
            Angular CLI automatically generates two sets of bundles: modern ES2015+ for newer browsers
            and ES5 for older browsers. Browsers automatically load the appropriate version.
          </p>
        </div>

        <div class="tip-box">
          <h4>ğŸ¯ Performance Monitoring</h4>
          <ul>
            <li>Use Lighthouse for performance audits</li>
            <li>Monitor Core Web Vitals (LCP, FID, CLS)</li>
            <li>Set up bundle size tracking in CI/CD</li>
            <li>Use Real User Monitoring (RUM) tools</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Performance Tips">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Webpack Performance Tips</h3>
        <p>
          Optimize both build-time performance (faster development) and runtime performance (faster app)
          with these proven strategies and best practices.
        </p>
        
        <h4>Build Performance</h4>
        <ul>
          <li><strong>Incremental Builds:</strong> Rebuild only changed files</li>
          <li><strong>Build Cache:</strong> Use Angular CLI's persistent cache</li>
          <li><strong>Parallel Processing:</strong> Leverage multi-core processors</li>
          <li><strong>Reduce Checks:</strong> Disable unnecessary type checking in dev</li>
        </ul>

        <h4>Runtime Performance</h4>
        <ul>
          <li><strong>OnPush Detection:</strong> Optimize change detection</li>
          <li><strong>Lazy Loading:</strong> Load features on demand</li>
          <li><strong>Virtual Scrolling:</strong> Handle large lists efficiently</li>
          <li><strong>Pure Pipes:</strong> Avoid unnecessary recalculations</li>
          <li><strong>TrackBy Functions:</strong> Optimize ngFor rendering</li>
        </ul>

        <h4>Network Performance</h4>
        <ul>
          <li>ğŸŒ HTTP caching with shareReplay</li>
          <li>ğŸ“¡ Preload critical resources</li>
          <li>ğŸ–¼ï¸ Lazy load images with loading="lazy"</li>
          <li>ğŸ’¾ Service worker for offline support</li>
          <li>âš¡ CDN for static assets</li>
        </ul>

        <div class="code-note"><p>Performance optimization examples include OnPush change detection, lazy loading strategies, and Angular-specific build optimizations</p></div>

        <div class="best-practices">
          <h4>âœ… Performance Best Practices</h4>
          <ul>
            <li><strong>Measure First:</strong> Use profiling before optimizing</li>
            <li><strong>Lazy Load Routes:</strong> Split code by feature</li>
            <li><strong>OnPush Everywhere:</strong> Where possible, use OnPush</li>
            <li><strong>Avoid Memory Leaks:</strong> Unsubscribe from observables</li>
            <li><strong>Cache API Calls:</strong> Use shareReplay for shared data</li>
            <li><strong>Monitor Bundle Size:</strong> Set budgets and track growth</li>
          </ul>
        </div>

        <div class="info-box">
          <h4>ğŸ’¡ Development vs Production</h4>
          <p>
            Balance build speed in development with runtime performance in production.
            Use fast incremental builds in dev, and aggressive optimizations in production.
          </p>
        </div>

        <div class="tip-box">
          <h4>ğŸ¯ Quick Performance Wins</h4>
          <ul>
            <li>Enable persistent build cache (automatic in Angular 13+)</li>
            <li>Use OnPush change detection strategy</li>
            <li>Lazy load non-critical routes</li>
            <li>Remove unused dependencies with npm dedupe</li>
            <li>Use async pipe in templates (auto-unsubscribe)</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Common Issues">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Troubleshooting Common Webpack Issues</h3>
        <p>
          Learn to identify and resolve common Webpack-related issues that occur during Angular development
          and build processes.
        </p>
        
        <h4>Common Error Categories</h4>
        <ul>
          <li><strong>Module Resolution:</strong> Can't find or resolve modules</li>
          <li><strong>Memory Issues:</strong> Heap out of memory errors</li>
          <li><strong>Build Failures:</strong> Production build errors</li>
          <li><strong>Performance:</strong> Slow build times</li>
          <li><strong>Runtime Issues:</strong> Code works in dev, fails in prod</li>
        </ul>

        <h4>Debugging Strategies</h4>
        <ul>
          <li>ğŸ” Use verbose logging: <code>ng build --verbose</code></li>
          <li>ğŸ“Š Analyze bundles with webpack-bundle-analyzer</li>
          <li>ğŸ§ª Test production builds locally</li>
          <li>ğŸ” Check browser console for runtime errors</li>
          <li>ğŸ“ Enable source maps for debugging</li>
        </ul>

        <h4>Prevention Tips</h4>
        <ul>
          <li>Set up CI/CD to catch issues early</li>
          <li>Configure bundle size budgets</li>
          <li>Regular dependency updates</li>
          <li>Code reviews for import patterns</li>
          <li>Monitor build performance metrics</li>
        </ul>

        <div class="code-note"><p>Common issues include module resolution errors, memory issues, and build failures - solutions typically involve cache clearing, dependency updates, and configuration adjustments</p></div>

        <div class="warning-box">
          <h4>âš ï¸ Common Pitfalls</h4>
          <ul>
            <li>Importing entire libraries instead of specific modules</li>
            <li>Forgetting to update package-lock.json</li>
            <li>Not testing production builds before deployment</li>
            <li>Ignoring bundle size budget warnings</li>
            <li>Using outdated or incompatible dependencies</li>
          </ul>
        </div>

        <div class="info-box">
          <h4>ğŸ’¡ When Things Go Wrong</h4>
          <p>
            Start with the basics: clear caches, delete node_modules and reinstall, check for conflicting
            dependencies. Many issues are resolved by ensuring a clean build environment.
          </p>
        </div>

        <div class="tip-box">
          <h4>ğŸ¯ Debugging Workflow</h4>
          <ol>
            <li>Read the error message carefully</li>
            <li>Check Angular/Webpack version compatibility</li>
            <li>Clear caches and rebuild</li>
            <li>Test with minimal reproduction</li>
            <li>Check GitHub issues for known problems</li>
            <li>Enable verbose logging for details</li>
          </ol>
        </div>
      </div>
    </ng-template>
  </mat-tab>
</mat-tab-group>
