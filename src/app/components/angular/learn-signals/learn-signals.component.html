<h2 class="header">Signals</h2>
<label>Signals are Angular's reactive primitives for managing state changes and dependencies, providing fine-grained reactivity and better performance.</label>

<mat-tab-group>
  <mat-tab label="Basic Signals">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>What are Signals?</h3>
        <p>
          Signals are a reactive primitive introduced in Angular 16 that notify interested consumers when their value changes.
          They provide a new way to manage state and reactivity in Angular applications with better performance and developer experience.
        </p>
        
        <h4>Key Concepts</h4>
        <ul>
          <li><strong>Writable Signal:</strong> Created with <code>signal()</code>, can be read and updated</li>
          <li><strong>Computed Signal:</strong> Derived from other signals, automatically updates</li>
          <li><strong>Effect:</strong> Side effects that run when signals change</li>
          <li><strong>Fine-grained Reactivity:</strong> Only affected components update</li>
        </ul>

        <h4>Why Use Signals?</h4>
        <ul>
          <li>üöÄ <strong>Better Performance:</strong> Fine-grained reactivity, no zone.js overhead</li>
          <li>üéØ <strong>Simpler Code:</strong> Less boilerplate than RxJS for simple state</li>
          <li>üîç <strong>Better Debugging:</strong> Clear dependency graph</li>
          <li>‚ö° <strong>Automatic Updates:</strong> Computed values update automatically</li>
          <li>üèÉ <strong>Zoneless Future:</strong> Enables running without zone.js</li>
        </ul>

        <pre><code class="language-typescript">{{ basicSignals }}</code></pre>

        <div class="info-box">
          <h4>üí° Signal Reading Syntax</h4>
          <p>
            Signals use a function call syntax to read values: <code>count()</code>.
            This allows Angular to track dependencies automatically and is necessary for the reactive system to work.
          </p>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Computed Signals">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Computed Signals</h3>
        <p>
          Computed signals derive their value from other signals. They automatically track dependencies
          and only recompute when dependent signals change, making them highly efficient.
        </p>
        
        <h4>Characteristics</h4>
        <ul>
          <li><strong>Readonly:</strong> Cannot be directly set, only computed from dependencies</li>
          <li><strong>Lazy:</strong> Only computes when read and dependencies have changed</li>
          <li><strong>Memoized:</strong> Caches result until dependencies change</li>
          <li><strong>Automatic Dependencies:</strong> Tracks all signals read during computation</li>
        </ul>

        <h4>When to Use Computed</h4>
        <ul>
          <li>Deriving data from other signals</li>
          <li>Filtering or transforming signal data</li>
          <li>Creating complex calculations</li>
          <li>Building dependent state chains</li>
        </ul>

        <pre><code class="language-typescript">{{ computedSignals }}</code></pre>

        <div class="tip-box">
          <h4>üéØ Best Practices</h4>
          <ul>
            <li>Keep computed functions pure (no side effects)</li>
            <li>Computed signals should be cheap to calculate</li>
            <li>Use computed for derived state, effect for side effects</li>
            <li>Avoid circular dependencies between computed signals</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Effects">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Effects</h3>
        <p>
          Effects are operations that run when signals they depend on change. Unlike computed signals,
          effects are designed for side effects like logging, API calls, or DOM manipulation.
        </p>
        
        <h4>Effect Characteristics</h4>
        <ul>
          <li>Run automatically when dependent signals change</li>
          <li>Should be used for side effects only</li>
          <li>Support cleanup functions</li>
          <li>Run at least once on creation</li>
        </ul>

        <h4>Common Use Cases</h4>
        <ul>
          <li>Logging or analytics</li>
          <li>Synchronizing with localStorage</li>
          <li>Triggering API calls</li>
          <li>DOM manipulation</li>
          <li>WebSocket connections</li>
        </ul>

        <pre><code class="language-typescript">{{ effectSignals }}</code></pre>

        <div class="warning-box">
          <h4>‚ö†Ô∏è Important Notes</h4>
          <ul>
            <li>Effects run in an async task by default</li>
            <li>Don't update signals within effects (can cause infinite loops)</li>
            <li>Use <code>allowSignalWrites</code> option if absolutely necessary</li>
            <li>Effects should not return values - use computed instead</li>
            <li>Always provide cleanup for subscriptions or timers</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Signal Inputs">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Signal-based Inputs (Angular 17.1+)</h3>
        <p>
          Signal inputs provide a reactive way to handle component inputs, replacing the traditional
          <code>&#64;Input()</code> decorator with a more powerful and type-safe API.
        </p>
        
        <h4>Advantages Over <code>&#64;Input()</code></h4>
        <ul>
          <li>Better type safety and inference</li>
          <li>Can be used in computed and effect</li>
          <li>Required inputs are type-checked at compile time</li>
          <li>Transform functions are type-safe</li>
          <li>No OnChanges lifecycle hook needed</li>
        </ul>

        <h4>Input Types</h4>
        <ul>
          <li><code>input()</code> - Optional input with default</li>
          <li><code>input.required()</code> - Required input</li>
          <li><code>model()</code> - Two-way binding signal</li>
          <li><code>linkedSignal()</code> - Writable signal linked to input</li>
        </ul>

        <pre><code class="language-typescript">{{ signalInputs }}</code></pre>

        <div class="migration-tip">
          <h4>üì¶ Migration Path</h4>
          <pre><code>// Before (traditional)
&#64;Input() name: string;
&#64;Input() required email!: string;
&#64;Output() nameChange = new EventEmitter&lt;string&gt;();

// After (signals)
name = input&lt;string&gt;('');
email = input.required&lt;string&gt;();
name = model&lt;string&gt;('');</code></pre>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Linked Signals">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Linked Signals (Angular 18+)</h3>
        <p>
          Linked signals create a writable signal that tracks an input signal but can also be modified
          independently. They reset to the source value when the source changes.
        </p>
        
        <h4>Use Cases</h4>
        <ul>
          <li>Form fields that need local edits and reset functionality</li>
          <li>Filters that can be temporarily overridden</li>
          <li>Draft state that syncs with saved data</li>
          <li>Optimistic UI updates with rollback</li>
        </ul>

        <pre><code class="language-typescript">{{ linkedSignal }}</code></pre>

        <div class="pattern-box">
          <h4>üé® Common Pattern: Editable with Reset</h4>
          <pre><code>// Perfect for forms where you want to:
// 1. Show initial value from parent
// 2. Allow local edits
// 3. Reset back to original

editableValue = linkedSignal(() =&gt; this.originalValue());
hasChanges = computed(() =&gt; 
  this.editableValue() !== this.originalValue()
);</code></pre>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Signals & RxJS">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Interoperability with RxJS</h3>
        <p>
          Angular provides utilities to convert between signals and observables, allowing you to
          leverage both paradigms in your application.
        </p>
        
        <h4>Conversion Functions</h4>
        <ul>
          <li><code>toSignal()</code> - Converts Observable to Signal</li>
          <li><code>toObservable()</code> - Converts Signal to Observable</li>
        </ul>

        <h4>When to Use Each</h4>
        <table>
          <tr>
            <th>Use Signals For</th>
            <th>Use RxJS For</th>
          </tr>
          <tr>
            <td>Component state</td>
            <td>HTTP requests</td>
          </tr>
          <tr>
            <td>Simple transformations</td>
            <td>Complex async operations</td>
          </tr>
          <tr>
            <td>Derived values</td>
            <td>Debouncing, throttling</td>
          </tr>
          <tr>
            <td>UI state</td>
            <td>WebSocket streams</td>
          </tr>
        </table>

        <pre><code class="language-typescript">{{ signalsRxjs }}</code></pre>

        <div class="tip-box">
          <h4>üí° Best Practices</h4>
          <ul>
            <li>Use signals for synchronous state management</li>
            <li>Use RxJS for complex async operations</li>
            <li>Convert at the boundaries (service ‚Üí signal)</li>
            <li>Prefer signals for component-local state</li>
            <li>toSignal requires initialValue or can return undefined</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Advanced Patterns">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Advanced Signal Patterns</h3>
        <p>
          These patterns demonstrate how to build sophisticated state management solutions using signals.
        </p>

        <pre><code class="language-typescript">{{ advancedPatterns }}</code></pre>

        <div class="best-practices">
          <h4>‚úÖ Signal Best Practices</h4>
          <ul>
            <li><strong>Immutability:</strong> Always update signals immutably</li>
            <li><strong>Privacy:</strong> Expose readonly signals, keep writable private</li>
            <li><strong>Granularity:</strong> Break state into smaller signals for better performance</li>
            <li><strong>Computation:</strong> Use computed for derived state, not manual updates</li>
            <li><strong>Effects:</strong> Keep effects focused and provide cleanup</li>
            <li><strong>Testing:</strong> Signals are easy to test - just set values and read results</li>
          </ul>
        </div>

        <div class="performance-tip">
          <h4>üöÄ Performance Tips</h4>
          <ul>
            <li>Signals enable OnPush-like performance everywhere</li>
            <li>Computed signals only recalculate when dependencies change</li>
            <li>No need for ChangeDetectorRef or manual detection</li>
            <li>Works towards zoneless Angular applications</li>
            <li>Fine-grained updates mean less work for Angular</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>
  <mat-tab label="Interview Q&A">
    <ng-template matTabContent>
      <div class="interview-section">
        <h3>Expert/Senior/Architect Level Interview Questions</h3>
        
        <div class="question-block">
          <h4>Q1: How do Signals compare to RxJS in terms of architecture and when should you use each?</h4>
          <div class="answer">
            <p><strong>Answer:</strong></p>
            <ul>
              <li><strong>Signals:</strong> Synchronous, pull-based, fine-grained reactivity. Best for component state and derived values</li>
              <li><strong>RxJS:</strong> Asynchronous, push-based, stream-oriented. Best for async operations, events, HTTP requests</li>
              <li><strong>Performance:</strong> Signals have minimal overhead and enable zoneless apps; RxJS has higher memory footprint</li>
              <li><strong>Composition:</strong> Use toSignal() and toObservable() at boundaries for interoperability</li>
              <li><strong>Architecture:</strong> Signals for UI state, RxJS for business logic and data layer</li>
              <li><strong>Migration:</strong> Gradually migrate from RxJS to signals for synchronous state</li>
              <li><strong>Debugging:</strong> Signals have simpler dependency graphs; RxJS requires marble diagrams</li>
            </ul>
          </div>
        </div>

        <div class="question-block">
          <h4>Q2: Explain the internal mechanics of how Signals achieve fine-grained reactivity.</h4>
          <div class="answer">
            <p><strong>Answer:</strong></p>
            <ul>
              <li><strong>Dependency Tracking:</strong> Signals track which computed/effects read them during execution</li>
              <li><strong>Notification Graph:</strong> Creates a directed acyclic graph (DAG) of dependencies</li>
              <li><strong>Change Detection:</strong> Only notifies dependent consumers when signal value actually changes</li>
              <li><strong>Lazy Evaluation:</strong> Computed signals don't recalculate until read and dependencies changed</li>
              <li><strong>Glitch-free:</strong> Ensures computed signals update atomically, avoiding intermediate states</li>
              <li><strong>Memory Efficiency:</strong> No subscription objects needed, automatic cleanup</li>
              <li><strong>Compiler Integration:</strong> Angular compiler can optimize signal usage at build time</li>
            </ul>
          </div>
        </div>

        <div class="question-block">
          <h4>Q3: How would you architect a complex state management solution using only Signals?</h4>
          <div class="answer">
            <p><strong>Answer:</strong></p>
            <ul>
              <li><strong>Signal Store Pattern:</strong> Create injectable store services with private writable signals, expose readonly</li>
              <li><strong>Selectors:</strong> Use computed signals as memoized selectors for derived state</li>
              <li><strong>Actions:</strong> Methods that update signals with immutable updates</li>
              <li><strong>Entity Management:</strong> Use Map/Set with signals for normalized entity state</li>
              <li><strong>Async Loading:</strong> Combine with toSignal() for loading states from HTTP</li>
              <li><strong>Undo/Redo:</strong> Maintain history of signal states for time-travel debugging</li>
              <li><strong>Devtools:</strong> Integrate with Angular DevTools for signal inspection</li>
            </ul>
            <pre><code>export class UserStore &#123;
  private _users = signal&lt;User[]&gt;([]);
  users = this._users.asReadonly();
  
  activeUser = signal&lt;string | null&gt;(null);
  selectedUser = computed(() =&gt; 
    this._users().find(u =&gt; u.id === this.activeUser())
  );
  
  addUser(user: User) &#123;
    this._users.update(users =&gt; [...users, user]);
  &#125;
&#125;</code></pre>
          </div>
        </div>

        <div class="question-block">
          <h4>Q4: What are the challenges and solutions for using Signals in SSR and hydration?</h4>
          <div class="answer">
            <p><strong>Answer:</strong></p>
            <ul>
              <li><strong>Hydration Mismatch:</strong> Ensure signal values match between server and client</li>
              <li><strong>Effect Execution:</strong> Effects run differently in SSR - handle with runInInjectionContext</li>
              <li><strong>Transfer State:</strong> Use TransferState to pass signal values from server to client</li>
              <li><strong>Cleanup:</strong> Properly destroy effects in SSR to prevent memory leaks</li>
              <li><strong>Conditional Effects:</strong> Check isPlatformBrowser() before effects with browser-only APIs</li>
              <li><strong>Initial Values:</strong> Design signals with SSR-safe initial values</li>
              <li><strong>Progressive Enhancement:</strong> Use signals to enhance server-rendered content</li>
            </ul>
          </div>
        </div>

        <div class="question-block">
          <h4>Q5: How do you handle computed signal optimization and prevent unnecessary recalculations?</h4>
          <div class="answer">
            <p><strong>Answer:</strong></p>
            <ul>
              <li><strong>Memoization:</strong> Computed signals automatically memoize results based on dependencies</li>
              <li><strong>Equality Checks:</strong> Use equal option for custom equality comparison</li>
              <li><strong>Granular Signals:</strong> Break complex state into smaller signals for precise updates</li>
              <li><strong>Structural Sharing:</strong> Maintain object references when possible in updates</li>
              <li><strong>Avoid Deep Computations:</strong> Keep computed functions cheap; expensive operations should be async</li>
              <li><strong>Profiling:</strong> Use Angular DevTools to identify hot computed signals</li>
              <li><strong>Batching:</strong> Group signal updates to minimize computed recalculations</li>
            </ul>
            <pre><code>// Optimize with custom equality
const expensiveComputed = computed(
  () =&gt; complexCalculation(data()),
  &#123; equal: (a, b) =&gt; a.id === b.id &#125;
);</code></pre>
          </div>
        </div>
      </div>
    </ng-template>
  </mat-tab>
</mat-tab-group>
