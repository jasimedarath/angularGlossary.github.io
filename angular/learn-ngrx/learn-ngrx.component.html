<h2 class="header">NgRx - State Management</h2>
<label>NgRx is a reactive state management library for Angular, inspired by Redux. It provides a predictable state container with RxJS integration.</label>

<mat-tab-group>
  <mat-tab label="Introduction">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>What is NgRx?</h3>
        <p>
          NgRx provides state management for Angular applications based on the Redux pattern.
          It uses RxJS observables to handle async data and provides a single source of truth for application state.
        </p>
        
        <h4>Core Concepts</h4>
        <ul>
          <li><strong>Store:</strong> Single immutable state tree</li>
          <li><strong>Actions:</strong> Events that describe state changes</li>
          <li><strong>Reducers:</strong> Pure functions that update state</li>
          <li><strong>Selectors:</strong> Query state slices</li>
          <li><strong>Effects:</strong> Handle side effects (HTTP, etc.)</li>
        </ul>

        <h4>Why Use NgRx?</h4>
        <ul>
          <li>ğŸ“¦ <strong>Single Source of Truth:</strong> All state in one place</li>
          <li>ğŸ”„ <strong>Predictable:</strong> State changes via pure functions</li>
          <li>ğŸ› <strong>Debuggable:</strong> Redux DevTools integration</li>
          <li>â±ï¸ <strong>Time Travel:</strong> Debug by replaying actions</li>
          <li>ğŸ§ª <strong>Testable:</strong> Pure functions easy to test</li>
          <li>ğŸš€ <strong>Performance:</strong> OnPush change detection</li>
        </ul>

        <pre><code class="language-typescript">{{ introduction }}</code></pre>

        <div class="info-box">
          <h4>ğŸ’¡ When to Use NgRx</h4>
          <ul>
            <li>Complex state management</li>
            <li>State shared across many components</li>
            <li>Need for time-travel debugging</li>
            <li>Large teams needing structure</li>
            <li>State persistence requirements</li>
          </ul>
        </div>

        <div class="warning-box">
          <h4>âš ï¸ When NOT to Use NgRx</h4>
          <ul>
            <li>Small applications with simple state</li>
            <li>Prototypes and POCs</li>
            <li>When team unfamiliar with Redux patterns</li>
            <li>Local component state (use signals or ComponentStore)</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Store & State">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Store and State Management</h3>
        <p>
          The Store holds the entire application state in a single immutable object tree.
          It's the single source of truth for your application data.
        </p>

        <pre><code class="language-typescript">{{ storeAndState }}</code></pre>

        <div class="architecture-diagram">
          <h4>ğŸ—ï¸ State Architecture</h4>
          <pre><code>AppState
  â”œâ”€â”€ users: UserState
  â”‚   â”œâ”€â”€ entities: &#123;&#125;
  â”‚   â”œâ”€â”€ ids: []
  â”‚   â”œâ”€â”€ selectedId: null
  â”‚   â””â”€â”€ loading: false
  â”œâ”€â”€ products: ProductState
  â””â”€â”€ auth: AuthState</code></pre>
        </div>

        <div class="tip-box">
          <h4>ğŸ’¡ State Design Tips</h4>
          <ul>
            <li>Keep state flat and normalized</li>
            <li>Use Entity Adapter for collections</li>
            <li>Separate data from UI state</li>
            <li>Store IDs, not references</li>
            <li>Use TypeScript interfaces</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Actions">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Actions - Events that Describe Changes</h3>
        <p>
          Actions are plain objects that represent events in your application.
          They're the only way to trigger state changes.
        </p>

        <pre><code class="language-typescript">{{ actions }}</code></pre>

        <div class="naming-convention">
          <h4>ğŸ“ Action Naming Convention</h4>
          <table>
            <tr>
              <th>Pattern</th>
              <th>Example</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>[Source] Event</td>
              <td>[Login Page] Login</td>
              <td>User initiated</td>
            </tr>
            <tr>
              <td>[API] Success</td>
              <td>[Auth API] Login Success</td>
              <td>API success</td>
            </tr>
            <tr>
              <td>[API] Failure</td>
              <td>[Auth API] Login Failure</td>
              <td>API error</td>
            </tr>
          </table>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Reducers">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Reducers - Pure Functions that Update State</h3>
        <p>
          Reducers are pure functions that take current state and an action,
          and return new state. They must be synchronous and side-effect free.
        </p>

        <pre><code class="language-typescript">{{ reducers }}</code></pre>

        <div class="rules-box">
          <h4>ğŸ“ Reducer Rules</h4>
          <ul>
            <li>âœ… Must be pure functions</li>
            <li>âœ… Always return new state (immutability)</li>
            <li>âœ… No side effects (HTTP, localStorage, etc.)</li>
            <li>âœ… Handle all relevant actions</li>
            <li>âŒ Never mutate state directly</li>
            <li>âŒ No async operations</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Selectors">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Selectors - Query State Efficiently</h3>
        <p>
          Selectors are pure functions for querying state. They're memoized
          for performance and composable for complex queries.
        </p>

        <pre><code class="language-typescript">{{ selectors }}</code></pre>

        <div class="benefits-box">
          <h4>ğŸ¯ Selector Benefits</h4>
          <ul>
            <li>ğŸš€ <strong>Memoization:</strong> Only recompute when inputs change</li>
            <li>ğŸ”§ <strong>Composition:</strong> Build complex from simple</li>
            <li>ğŸ§ª <strong>Testable:</strong> Pure functions</li>
            <li>ğŸ“ <strong>Type-safe:</strong> Full TypeScript support</li>
            <li>ğŸ¨ <strong>Reusable:</strong> Share across components</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Effects">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Effects - Handle Side Effects</h3>
        <p>
          Effects handle async operations and side effects. They listen for actions,
          perform side effects (HTTP, localStorage), and dispatch new actions.
        </p>

        <pre><code class="language-typescript">{{ effects }}</code></pre>

        <div class="operator-guide">
          <h4>ğŸ”§ Effect Operators Guide</h4>
          <table>
            <tr>
              <th>Operator</th>
              <th>Behavior</th>
              <th>Use Case</th>
            </tr>
            <tr>
              <td>switchMap</td>
              <td>Cancel previous</td>
              <td>Search, autocomplete</td>
            </tr>
            <tr>
              <td>mergeMap</td>
              <td>Run in parallel</td>
              <td>Bulk operations</td>
            </tr>
            <tr>
              <td>concatMap</td>
              <td>Sequential</td>
              <td>Order matters</td>
            </tr>
            <tr>
              <td>exhaustMap</td>
              <td>Ignore new</td>
              <td>Prevent duplicates</td>
            </tr>
          </table>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Entity Adapter">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Entity Adapter - Manage Collections</h3>
        <p>
          Entity Adapter provides pre-built functions for managing normalized collections.
          It handles common CRUD operations and provides memoized selectors.
        </p>

        <pre><code class="language-typescript">{{ entityAdapter }}</code></pre>

        <div class="methods-box">
          <h4>ğŸ› ï¸ Entity Adapter Methods</h4>
          <ul>
            <li><strong>Add:</strong> addOne, addMany, addAll</li>
            <li><strong>Set:</strong> setOne, setMany, setAll</li>
            <li><strong>Update:</strong> updateOne, updateMany</li>
            <li><strong>Remove:</strong> removeOne, removeMany, removeAll</li>
            <li><strong>Upsert:</strong> upsertOne, upsertMany</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Component Store">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Component Store - Local State Management</h3>
        <p>
          Component Store manages component-level state with less boilerplate.
          Perfect for local UI state that doesn't need to be global.
        </p>

        <pre><code class="language-typescript">{{ componentStore }}</code></pre>

        <div class="comparison-box">
          <h4>âš–ï¸ Global Store vs Component Store</h4>
          <table>
            <tr>
              <th>Feature</th>
              <th>Global Store</th>
              <th>Component Store</th>
            </tr>
            <tr>
              <td>Scope</td>
              <td>Application-wide</td>
              <td>Component-level</td>
            </tr>
            <tr>
              <td>Boilerplate</td>
              <td>High</td>
              <td>Low</td>
            </tr>
            <tr>
              <td>Actions</td>
              <td>Required</td>
              <td>Optional</td>
            </tr>
            <tr>
              <td>DevTools</td>
              <td>Yes</td>
              <td>No</td>
            </tr>
            <tr>
              <td>Use Case</td>
              <td>Shared state</td>
              <td>Local state</td>
            </tr>
          </table>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Signal Store">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>Signal Store - Modern State Management</h3>
        <p>
          Signal Store (NgRx 17+) combines signals with state management
          for a simpler, more reactive API with less boilerplate.
        </p>

        <pre><code class="language-typescript">{{ signalStore }}</code></pre>

        <div class="evolution-box">
          <h4>ğŸ”„ NgRx Evolution</h4>
          <ul>
            <li><strong>Traditional:</strong> Actions â†’ Reducers â†’ Selectors â†’ Effects</li>
            <li><strong>Component Store:</strong> Updaters â†’ Selectors â†’ Effects</li>
            <li><strong>Signal Store:</strong> State â†’ Computed â†’ Methods (simplest!)</li>
          </ul>
        </div>

        <div class="tip-box">
          <h4>ğŸ’¡ When to Use Signal Store</h4>
          <ul>
            <li>New Angular 16+ projects</li>
            <li>Want simpler API than traditional store</li>
            <li>Embracing signals for reactivity</li>
            <li>Component or feature state</li>
          </ul>
        </div>
      </div>
    </ng-template>
  </mat-tab>

  <mat-tab label="Best Practices">
    <ng-template matTabContent>
      <div class="tab-content">
        <h3>NgRx Best Practices</h3>

        <pre><code class="language-typescript">{{ bestPractices }}</code></pre>

        <div class="best-practices-grid">
          <div class="do-box">
            <h4>âœ… DO</h4>
            <ul>
              <li>Use OnPush change detection</li>
              <li>Normalize state shape</li>
              <li>Keep reducers pure</li>
              <li>Handle all errors in effects</li>
              <li>Use Entity Adapter for collections</li>
              <li>Write comprehensive tests</li>
              <li>Use Redux DevTools</li>
            </ul>
          </div>
          <div class="dont-box">
            <h4>âŒ DON'T</h4>
            <ul>
              <li>Mutate state directly</li>
              <li>Put logic in actions</li>
              <li>Dispatch in reducers</li>
              <li>Use store for all state</li>
              <li>Forget error handling</li>
              <li>Nest state deeply</li>
              <li>Skip testing</li>
            </ul>
          </div>
        </div>
      </div>
    </ng-template>
  </mat-tab>
</mat-tab-group>
